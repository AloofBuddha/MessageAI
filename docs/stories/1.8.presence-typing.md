# Story 1.8: Online/Offline Presence & Typing Indicators

## Status
**Draft**

## Story

**As a** user,  
**I want** to see when contacts are online and when they're typing,  
**so that** I know if they're available and engaged in the conversation.

## Acceptance Criteria

1. User presence tracked in Firestore `users` collection with: isOnline (boolean), lastSeen (timestamp)
2. App updates user's `isOnline` to true on login/foreground, false on logout/background/disconnect
3. Firestore onDisconnect() hook ensures presence updates even if app crashes
4. Conversation list shows online status indicator (green dot) for online contacts
5. Chat screen shows "Online" or "Last seen X minutes ago" at top
6. Typing indicator implemented: when user types, Firestore document updated with `isTyping: true` and typingAt timestamp
7. Typing indicator shown in chat screen when other participant is typing ("Alice is typing...")
8. Typing indicator auto-clears after 3 seconds of inactivity or when message is sent
9. Typing status scoped to specific conversation (not global)
10. Presence and typing updates are real-time (Firestore listeners)

## Tasks / Subtasks

- [ ] **Task 1: Update User Model for Presence** (AC: 1)
  - [ ] Ensure User interface includes: `isOnline: boolean`, `lastSeen: Date`
  - [ ] Update `shared/src/types/models.ts` if needed
  - [ ] Rebuild shared package

- [ ] **Task 2: Create Presence Service** (AC: 2, 3)
  - [ ] Create `mobile/src/services/presence/presenceService.ts`
  - [ ] Implement `setUserOnline(userId): Promise<void>`
  - [ ] Implement `setUserOffline(userId): Promise<void>`
  - [ ] Use Firebase Realtime Database for onDisconnect hooks (more reliable than Firestore)
  - [ ] Alternative: Use Firestore with manual heartbeat (simpler for MVP)

- [ ] **Task 3: Track App Lifecycle for Presence** (AC: 2)
  - [ ] In `authStore.login()`: call `setUserOnline()`
  - [ ] In `authStore.logout()`: call `setUserOffline()`
  - [ ] Use `AppState` listener: foreground → online, background → offline
  - [ ] Set up heartbeat: update `lastSeen` every 30 seconds when app active

- [ ] **Task 4: Implement onDisconnect Hook** (AC: 3)
  - [ ] Use Firebase Realtime Database `.onDisconnect()` API
  - [ ] On login: set `rtdb.ref('presence/{userId}').onDisconnect().set({ isOnline: false, lastSeen: serverTimestamp })`
  - [ ] Sync Realtime DB presence to Firestore Users collection

- [ ] **Task 5: Add Online Indicator to ConversationListItem** (AC: 4)
  - [ ] Fetch participant User objects for each conversation
  - [ ] Show green dot badge on avatar if user.isOnline === true
  - [ ] Use `Badge` component from React Native Paper

- [ ] **Task 6: Add Presence to Chat Screen Header** (AC: 5)
  - [ ] Fetch other participant's User object
  - [ ] Show "Online" if isOnline === true
  - [ ] Show "Last seen {time} ago" if offline
  - [ ] Use real-time listener: listen to `users/{participantId}` doc

- [ ] **Task 7: Create TypingIndicator Data Model** (AC: 6, 9)
  - [ ] Add `TypingIndicator` interface to `shared/src/types/models.ts`
  - [ ] Fields: conversationId, userId, isTyping, typingAt
  - [ ] Firestore collection: `/typing/{conversationId}` (subcollection or separate collection)

- [ ] **Task 8: Implement Typing Indicator Service** (AC: 6, 8)
  - [ ] Create `mobile/src/services/firestore/typingService.ts`
  - [ ] Implement `setTyping(conversationId, userId, isTyping): Promise<void>`
  - [ ] Implement `listenToTyping(conversationId, callback): Unsubscribe`
  - [ ] Auto-clear: use Firestore TTL or client-side timeout

- [ ] **Task 9: Integrate Typing in ChatInput** (AC: 6, 8)
  - [ ] In ChatInput: add `onChangeText` handler
  - [ ] Debounce: call `setTyping(true)` on first character
  - [ ] Clear typing: call `setTyping(false)` after 3 seconds of inactivity
  - [ ] Clear typing: call `setTyping(false)` when message sent

- [ ] **Task 10: Display Typing Indicator in Chat Screen** (AC: 7)
  - [ ] Listen to typing status for conversation
  - [ ] Filter out current user's typing status
  - [ ] Show "Alice is typing..." below chat messages
  - [ ] Style: gray italic text with animated dots

## Dev Notes

### Presence Architecture Choice
[Source: docs/architecture.md#backend-architecture]

**Option 1 (Recommended for MVP):** Use Firestore with manual heartbeat
- Simpler (no Realtime DB setup)
- Update `users/{userId}` with `isOnline` and `lastSeen` every 30 seconds
- Trade-off: Not 100% reliable if app crashes, but good enough for MVP

**Option 2 (Production):** Use Firebase Realtime Database
- More reliable `.onDisconnect()` hook
- Automatically sets user offline if connection drops
- Sync presence from RTDB to Firestore for queries

For MVP, use Option 1. Upgrade to Option 2 post-MVP if needed.

### Presence Service (Firestore + Heartbeat)
```typescript
// presenceService.ts
let heartbeatInterval: NodeJS.Timeout | null = null;

export async function startPresenceTracking(userId: string): Promise<void> {
  // Set online immediately
  await updateDoc(doc(firestore, 'users', userId), {
    isOnline: true,
    lastSeen: serverTimestamp(),
  });
  
  // Start heartbeat (every 30 seconds)
  heartbeatInterval = setInterval(async () => {
    await updateDoc(doc(firestore, 'users', userId), {
      lastSeen: serverTimestamp(),
    });
  }, 30000);
  
  // Listen to app state changes
  AppState.addEventListener('change', (state) => {
    if (state === 'active') {
      setUserOnline(userId);
    } else if (state === 'background' || state === 'inactive') {
      setUserOffline(userId);
    }
  });
}

export async function stopPresenceTracking(userId: string): Promise<void> {
  if (heartbeatInterval) {
    clearInterval(heartbeatInterval);
    heartbeatInterval = null;
  }
  
  await updateDoc(doc(firestore, 'users', userId), {
    isOnline: false,
    lastSeen: serverTimestamp(),
  });
}

export async function setUserOnline(userId: string): Promise<void> {
  await updateDoc(doc(firestore, 'users', userId), {
    isOnline: true,
    lastSeen: serverTimestamp(),
  });
}

export async function setUserOffline(userId: string): Promise<void> {
  await updateDoc(doc(firestore, 'users', userId), {
    isOnline: false,
    lastSeen: serverTimestamp(),
  });
}
```

### Typing Indicator Data Model
```typescript
// models.ts
export interface TypingIndicator {
  conversationId: string;
  userId: string;
  displayName: string;  // For display
  isTyping: boolean;
  typingAt: Date;
}
```

### Typing Service
```typescript
// typingService.ts
let typingTimeout: NodeJS.Timeout | null = null;

export async function setTyping(
  conversationId: string,
  userId: string,
  isTyping: boolean
): Promise<void> {
  const docRef = doc(firestore, `typing/${conversationId}_${userId}`);
  
  if (isTyping) {
    await setDoc(docRef, {
      conversationId,
      userId,
      isTyping: true,
      typingAt: serverTimestamp(),
    });
  } else {
    await deleteDoc(docRef);
  }
}

export function listenToTyping(
  conversationId: string,
  currentUserId: string,
  callback: (typingUsers: TypingIndicator[]) => void
): () => void {
  const q = query(
    collection(firestore, 'typing'),
    where('conversationId', '==', conversationId),
    where('isTyping', '==', true)
  );
  
  return onSnapshot(q, (snapshot) => {
    const typingUsers = snapshot.docs
      .map(doc => ({ id: doc.id, ...doc.data() } as TypingIndicator))
      .filter(t => t.userId !== currentUserId);  // Exclude self
    
    callback(typingUsers);
  });
}
```

### Typing in ChatInput
```typescript
// ChatInput.tsx
export function ChatInput({ conversationId }: ChatInputProps) {
  const [text, setText] = useState('');
  const [isTyping, setIsTyping] = useState(false);
  const typingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const userId = useAuthStore((s) => s.user!.id);
  
  const handleTextChange = (value: string) => {
    setText(value);
    
    // Start typing indicator
    if (!isTyping && value.length > 0) {
      setIsTyping(true);
      typingService.setTyping(conversationId, userId, true);
    }
    
    // Reset timeout
    if (typingTimeoutRef.current) {
      clearTimeout(typingTimeoutRef.current);
    }
    
    // Clear typing after 3 seconds of inactivity
    typingTimeoutRef.current = setTimeout(() => {
      setIsTyping(false);
      typingService.setTyping(conversationId, userId, false);
    }, 3000);
  };
  
  const handleSend = async () => {
    if (!text.trim()) return;
    
    // Clear typing immediately
    if (isTyping) {
      setIsTyping(false);
      typingService.setTyping(conversationId, userId, false);
    }
    
    await messagesStore.sendMessage(conversationId, text);
    setText('');
  };
  
  return (
    <View>
      <TextInput
        value={text}
        onChangeText={handleTextChange}
        placeholder="Type a message..."
      />
      <IconButton icon="send" onPress={handleSend} />
    </View>
  );
}
```

### Typing Indicator Display
```typescript
// ChatScreen.tsx
export default function ChatScreen() {
  const [typingUsers, setTypingUsers] = useState<TypingIndicator[]>([]);
  
  useEffect(() => {
    const unsubscribe = typingService.listenToTyping(
      conversationId,
      currentUserId,
      setTypingUsers
    );
    return unsubscribe;
  }, [conversationId]);
  
  return (
    <View>
      {/* Messages */}
      <FlatList data={messages} ... />
      
      {/* Typing Indicator */}
      {typingUsers.length > 0 && (
        <Text style={styles.typing}>
          {typingUsers[0].displayName} is typing...
        </Text>
      )}
      
      {/* Input */}
      <ChatInput conversationId={conversationId} />
    </View>
  );
}
```

### Testing
- **Presence:** Log in, verify green dot appears on other device's conversation list
- **Presence:** Background app, verify green dot disappears
- **Typing:** Type in chat, verify "... is typing" appears on other device
- **Typing:** Stop typing for 3 seconds, verify typing indicator clears
- **Typing:** Send message, verify typing indicator clears immediately

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_

