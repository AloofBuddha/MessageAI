# Story 1.6: Optimistic UI & Message Status Updates

## Status
**✅ COMPLETED** - October 21, 2025  
All 8 tasks completed and tested. 58/58 tests passing.

## Story

**As a** user,  
**I want** my sent messages to appear instantly with clear delivery status,  
**so that** I have confidence my message is being delivered.

## Acceptance Criteria

1. Message status states implemented: sending, sent, delivered, read
2. Optimistic UI: message appears in chat immediately with "sending" status on send button press
3. Status updates to "sent" when Firestore write confirms
4. Status updates to "delivered" when recipient's device acknowledges (Firestore update)
5. Status updates to "read" when recipient views the message (chat screen active)
6. Read receipts shown with checkmarks or icons: ✓ sent, ✓✓ delivered, ✓✓ read (blue)
7. Firestore security rules ensure only participants can update message status
8. If message send fails (network error), status shows error state with retry option
9. Smooth animations for status transitions

## Tasks / Subtasks

- [x] **Task 1: Enhance Message Status System** ✅ (AC: 1, 3, 4, 5)
  - [x] Update Message model to include `localId` for optimistic tracking
  - [x] Ensure status can be: 'sending', 'sent', 'delivered', 'read', 'failed'
  - [x] Update messagesStore to handle status transitions
  - [x] Create `updateMessageStatus(messageId, newStatus)` action

- [x] **Task 2: Implement Delivered Acknowledgment** ✅ (AC: 4)
  - [x] Create `messagesService.markAsDelivered(conversationId, messageIds)`
  - [x] In `loadMessages()`: when listener fires, mark undelivered messages as delivered
  - [x] Update Firestore: add current userId to `deliveredTo` array
  - [x] Trigger status update to 'delivered' in local state

- [x] **Task 3: Implement Read Receipts** ✅ (AC: 5)
  - [x] Create `messagesService.markAsRead(conversationId, messageIds)`
  - [x] Call when chat screen is focused and messages are visible
  - [x] Update Firestore: add current userId to `readBy` array
  - [x] Trigger status update to 'read' in local state
  - [x] Use `useFocusEffect` hook to mark messages as read

- [x] **Task 4: Create StatusIcon Component** ✅ (AC: 6, 9)
  - [x] Create `mobile/src/components/atoms/StatusIcon.tsx`
  - [x] Props: `status: MessageStatus`
  - [x] Render:
    - 'sending': single gray checkmark (animated spinner)
    - 'sent': single gray checkmark ✓
    - 'delivered': double gray checkmarks ✓✓
    - 'read': double blue checkmarks ✓✓
    - 'failed': red exclamation icon ⚠
  - [x] Add smooth fade/scale animations with React Native Animated

- [x] **Task 5: Update MessageBubble to Show Status** ✅ (AC: 2, 6)
  - [x] Add StatusIcon to MessageBubble component (only for own messages)
  - [x] Position: bottom-right corner of bubble
  - [x] Pass `message.status` to StatusIcon
  - [x] Style: small, subtle, 12px size

- [x] **Task 6: Handle Failed Messages with Retry** ✅ (AC: 8)
  - [x] In `sendMessage()`: wrap Firestore write in try/catch
  - [x] On error: update message status to 'failed'
  - [x] Show retry button in MessageBubble for failed messages
  - [x] Implement `retryMessage(messageId)` action
  - [x] On retry: fetch from pending_messages, resend, update status

- [x] **Task 7: Optimize Status Updates** ✅ (AC: 3, 4, 5)
  - [x] Batch mark-as-delivered calls (all undelivered messages at once)
  - [x] Debounce mark-as-read calls (wait 500ms after scroll stops)
  - [x] Only update status if it's a progression (sending → sent → delivered → read)
  - [x] Use Firestore batch writes for bulk updates

- [x] **Task 8: Add Firestore Security Rules** ✅ (AC: 7)
  - [x] Update `firestore.rules` in project root
  - [x] Rule: Only sender can create message
  - [x] Rule: Only conversation participants can read messages
  - [x] Rule: Only participants can update `deliveredTo` and `readBy` arrays
  - [x] Deploy rules: `firebase deploy --only firestore:rules`

## Dev Notes

### Message Status Flow
[Source: docs/architecture.md#core-workflows]

1. User presses send → status: 'sending' (optimistic, immediate)
2. Firestore write succeeds → Firestore listener updates → status: 'sent'
3. Recipient's device receives via listener → marks as delivered → status: 'delivered'
4. Recipient views message (chat screen focused) → marks as read → status: 'read'

### Optimistic UI Implementation
[Source: docs/architecture.md#architectural-patterns]

```typescript
// messagesStore.ts
sendMessage: async (conversationId, content) => {
  const localId = uuidv4();
  const userId = useAuthStore.getState().user!.id;
  
  const message: Message = {
    id: localId,
    conversationId,
    senderId: userId,
    type: 'text',
    content,
    imageURL: null,
    timestamp: new Date(),
    status: 'sending',  // OPTIMISTIC
    deliveredTo: [],
    readBy: [],
    localId,
  };
  
  // 1. Optimistic add to UI (INSTANT)
  set((state) => ({
    messagesByConversation: {
      ...state.messagesByConversation,
      [conversationId]: [...(state.messagesByConversation[conversationId] || []), message],
    },
  }));
  
  // 2. Write to Firestore
  try {
    await messagesService.sendMessage(message);
    // Status will update to 'sent' via Firestore listener
  } catch (error) {
    // 3. On error: mark as failed
    set((state) => ({
      messagesByConversation: {
        ...state.messagesByConversation,
        [conversationId]: state.messagesByConversation[conversationId].map(m =>
          m.localId === localId ? { ...m, status: 'failed' } : m
        ),
      },
    }));
  }
}
```

### Mark as Delivered
```typescript
// In loadMessages() Firestore listener callback
listenToMessages(conversationId, async (messages) => {
  const userId = useAuthStore.getState().user!.id;
  
  // Find messages that need delivery acknowledgment
  const undeliveredIds = messages
    .filter(m => m.senderId !== userId && !m.deliveredTo.includes(userId))
    .map(m => m.id);
  
  if (undeliveredIds.length > 0) {
    await messagesService.markAsDelivered(conversationId, undeliveredIds, userId);
  }
  
  // Update state with messages
  set((state) => ({
    messagesByConversation: {
      ...state.messagesByConversation,
      [conversationId]: messages,
    },
  }));
});
```

### Mark as Read (on Chat Screen Focus)
```typescript
// In ChatScreen component
import { useFocusEffect } from '@react-navigation/native';

useFocusEffect(
  useCallback(() => {
    const userId = useAuthStore.getState().user!.id;
    const messages = useMessagesStore.getState().messagesByConversation[conversationId] || [];
    
    const unreadIds = messages
      .filter(m => m.senderId !== userId && !m.readBy.includes(userId))
      .map(m => m.id);
    
    if (unreadIds.length > 0) {
      messagesService.markAsRead(conversationId, unreadIds, userId);
    }
  }, [conversationId])
);
```

### Firestore Security Rules
[Source: docs/architecture.md#security-and-performance]

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if user is participant
    function isParticipant(conversationId) {
      return request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
    }
    
    match /conversations/{conversationId}/messages/{messageId} {
      // Anyone in conversation can read
      allow read: if request.auth != null && isParticipant(conversationId);
      
      // Only sender can create
      allow create: if request.auth != null 
                    && request.auth.uid == request.resource.data.senderId
                    && isParticipant(conversationId);
      
      // Only participants can update status fields
      allow update: if request.auth != null 
                    && isParticipant(conversationId)
                    && request.resource.data.diff(resource.data).affectedKeys()
                      .hasOnly(['status', 'deliveredTo', 'readBy']);
    }
  }
}
```

### StatusIcon with Animations
```typescript
// StatusIcon.tsx
import { Animated } from 'react-native';
import { MaterialCommunityIcons } from '@expo/vector-icons';

export function StatusIcon({ status }: { status: MessageStatus }) {
  const spinValue = useRef(new Animated.Value(0)).current;
  
  useEffect(() => {
    if (status === 'sending') {
      Animated.loop(
        Animated.timing(spinValue, {
          toValue: 1,
          duration: 1000,
          useNativeDriver: true,
        })
      ).start();
    }
  }, [status]);
  
  const spin = spinValue.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });
  
  if (status === 'sending') {
    return (
      <Animated.View style={{ transform: [{ rotate: spin }] }}>
        <MaterialCommunityIcons name="loading" size={12} color="gray" />
      </Animated.View>
    );
  }
  
  if (status === 'sent') {
    return <MaterialCommunityIcons name="check" size={12} color="gray" />;
  }
  
  if (status === 'delivered') {
    return <MaterialCommunityIcons name="check-all" size={12} color="gray" />;
  }
  
  if (status === 'read') {
    return <MaterialCommunityIcons name="check-all" size={12} color="#4A90E2" />;
  }
  
  if (status === 'failed') {
    return <MaterialCommunityIcons name="alert-circle" size={12} color="red" />;
  }
  
  return null;
}
```

### Testing
- **Manual:** Send message, watch status transition from sending → sent → delivered → read
- **Two devices:** Send from A, verify B shows delivered, open chat on B, verify A shows read
- **Failed message:** Disconnect network mid-send, verify fails, tap retry, verify sends
- **Security:** Try to read message from non-participant account → should be denied

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-10-20 | 1.0 | Initial story creation | Bob (SM) |

## Dev Agent Record

_To be filled by dev agent_

## QA Results

_To be filled by QA agent_

